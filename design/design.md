# 设计模式

设计模式是解决问题的一种思想，和语言无关。通过不同场景采用适合的设计模式可以增加代码的可重用性、可扩展性、可维护性，最终使得我们的代码高内聚、低耦合。遵守五大原则，基本分为三大类型

## 原则

`单一职责原则`：一个程序只需要做好一件事。如果功能过于复杂就拆分开，保证每个部分的独立

`开放封闭原则`：对扩展开放，对修改封闭。增加需求时，扩展新代码，而不是修改源代码。这是软件设计的终极目标。

`里氏置换原则`：子类能覆盖父类，父类能出现的地方子类也能出现。

`接口独立原则`：保持接口的单一独立，避免出现“胖接口”。这点目前在 TS 中运用到。

`依赖导致原则`：面向接口编程，依赖于抽象而不依赖于具体。客户只专注接口而不用关注具体类的实现。俗称“鸭子类型”

## 类型

`创建型`：工厂模式(简单工厂，抽象工厂)，建造者模式，单例模式(普通单例，代理单例)，原型模式

`结构型`：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式

`行为型`：策略模式，模板方法模式，发布订阅模式，迭代器模式，职责链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。

### **工厂模式**

- 设计意图：是为了解决多个类似产品声明的问题，将产品的使用与创建解耦，工厂负责创建，客户无需关心创建过程和逻辑，只负责使用。
- 具体划分：分为简单工厂和抽象工厂模式。

#### 简单工厂：

- 设计：一个简单工厂类通过传入的参数决定创建哪一种实例
- 场景：
  - 工厂类负责生产的产品较少，一个静态方法用于创建产品；
  - 客户知道需要传入工厂的参数而并不关心具体的类创建逻辑。
- 总结：
  - 结构非常简单，易于使用，适合简单场景；
  - 每次增加一个产品，就需要一个具体的类，会使得简单工厂无比庞大而难以维护。

#### 抽象工厂：

- 设计：一个抽象工厂类以创建一系列相关或互相依赖的产品，将类的实例化延迟到子类，由客户选择用哪一个子类
- 场景：
  - 需要创建的产品是一系列相互关联或相互依赖的，并且客户知道将要使用哪一个子类；
- 总结：
  - 抽象工厂模式是让系列对象依赖或者关系能够正确的关联，具有较高扩展性，如果后续想要增加类时，直接编写一个新的子类即可；
  - 对于抽象工厂模式抛出的接口难以进行修改，因为一旦修改接口，所有实现类也需要修改。

### **建造者模式**

- 设计意图：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象，其使用和创建也是分开的
- 具体划分：建造者模式。

#### 建造者模式：

- 设计：一个建造者类内部实现一个复杂对象的具体创建逻辑，同样的构建过程可以创建不同的产品
- 场景：
  - 建造者类负责生产的对象内部复杂；
  - 复杂对象内部的属性相互关联。
- 总结：
  - 建造者模式是让复杂对象依赖或者关系能够正确的关联；
  - 当内部有变化时，会需要很多建造类。
- 例如：
  - 车：底盘，发动机，电气设备，车身，但是客户不需要知道这些具体细节和复杂的依赖，只需要知道类型就可以创建一个车

### **单例模式**

- 设计意图：是为了解决全局仅需一个实例的场景，例如全局状态管理(vuex)、window 对象、购物车和弹窗(固定配置)
- 具体划分：分为普通单例，代理单例。

#### 普通单例：

- 设计：一个类只能被实例一次，多次实例的话只返回最开始的实例
- 场景：
  - 全局仅需一个实例
- 总结：
  - 简单方便，不需要引用代理；
  - 单例类逻辑和实例化逻辑混在一起，违反了单一职责原则。

#### 代理单例：

- 设计：一个类只能被实例一次，多次实例的话只返回最开始的实例
- 场景：
  - 全局仅需一个实例
- 总结：
  - 全局只有一个实例，减少了内存的开销；
  - 单例类与代理类分隔开，代理类只负责实例化；
  - 略微比普通代理复杂，需要在公共位置定义代理单例逻辑。

### **原型模式**

- 设计意图：是为了将一个对象作为原型，通过拷贝原型创建新的对象，和简单工厂有点类似
- 具体划分：分为原型模式。

#### 原型模式

- 设计：克隆自己，生成一个新的对象
- 场景：
  - 类似与简单工厂
- 总结：
  - 不再依赖构造函数或者类创建对象，可以将这个对象作为一个模板生成更多的新对象；
  - 对于包含引用类型值的属性来说，所有实例在默认的情况下都会取得相同的属性值。

### **模块模式**

- 设计意图：模块模式是为了模拟类的概念，对于有类概念的语言则不适用，这个类拥有方法和变量，但是它可以选择性的抛出，作为其公有方法和公有属性，未抛出的就是其私有方法和私有属性，创建的模块可以再执行扩充、克隆、继承等类操作。
- 具体划分：模块模式。

### **适配器模式**

- 设计意图：适配器模式是为了兼容，适配器允许因为接口不兼容而不能在一起工作的类工作在一起，并且持有目标对象，实现了需要在一起工作的类的接口。
- 具体划分：适配器模式。

#### 适配器模式

- 设计：让接口不兼容而不能在一起工作的类工作在一起
- 场景：
  - 接口不兼容的类无法在一起正常工作，又不能修改目标类，一般这种类比较复杂老旧；
- 总结：
  - 通过适配器模式可以不更改源代码的情况下让不兼容的类在一起正常工作，主要是修改源代码收益并不高；
  - 过多的使用适配器模式，会让系统变得琐碎。
- 例如：
  - 一个中文交流的会谈，一个只会说英语的外国人就无法正常交谈，这时候翻译可以作为适配器去解析外国人的话语，这样就可以正常在一起交谈了

### **装饰器模式**

- 设计意图：装饰器模式是为了增强，装饰器类持有目标对象，所以会有目标类的方法，然后可以实现一些增强型接口。
- 具体划分：装饰器模式。

#### 装饰器模式

- 设计：不改变目标类，还能有一些增强型的功能
- 场景：
  - 想加一些其他功能，但又不能修改目标类，一般这种类比较复杂老旧；
- 总结：
  - 通过装饰器模式可以不更改源代码的情况下，让目标类实现增强型功能，装饰类的接口还可以反复再被装饰；
  - 过多的使用装饰器模式，会让系统变得复杂。
- 例如：
  - 一个手机有正常使用的功能，我给它加一个手机壳，它就增强其保护手机摔坏的能力，我可以在加手机壳的基础上在加个手机支架，它就又有了个看视频不用手拿着的功能，还有其他等等。这里手机壳和手机支架就起到装饰作用，而且也没影响到原有的功能。
  - 一个手机有打游戏功能，我给手机旁边放个风扇，降低温度也就增强其打游戏的能力。这里风扇就起到装饰作用，而且也没影响到原有的功能。
    下面例子中出现了嵌套，首先被风扇装饰，然后接着被手机壳/手机支架装饰

### **代理模式**

- 设计意图：代理模式是为了隔离，隔离访问对象和被访问对象，要访问本体，要先访问代理对象，通过代理做授权和控制，可起到保护的作用。
- 具体划分：代理模式。

#### 代理模式

- 设计：隔离访问对象和被访问对象，对是否能访问做控制
- 场景：
  - 一个类不方便暴露给太多客户，这时候就可以使用代理模式
- 总结：
  - 可以起到保护作用；
  - 需要做额外的工作，层层代理会影响速度
- 例如：
  - 经纪人和明星就是代理模式，商务和谈肯定不是直接和明星去谈，而是和经纪人去谈，当价格和档期都合适了，才能见到明星，明星才会表演节目

### **外观模式**

- 设计意图：外观模式本质就是内部封装交互和依赖，隐藏系统的复杂性，提供一个可以访问的接口
- 具体划分：外观模式

#### 外观模式

- 设计：
  - 由一个将子系统一组的接口集成在一起的高层接口，以提供一个一致的外观，减少外界与多个子系统之间的直接交互
- 场景：
  - 客户需要和多个子系统交互，过于复杂的时候
- 总结：
  - 减少系统的相互依赖，提高简便性；
  - 违反开放封闭原则，复杂逻辑改动会很麻烦
- 例如：
  - 外观模式常用于兼容处理
  ```javascript
  function addEvent(el, type, fn) {
    if (el.addEventlistener) {
      // 高级游览器添加事件DOM API
      el.addEventlistener(type, fn, false);
    } else if (el.attachEvent) {
      // 低版本游览器的添加事件API
      el.attachEvent(`on${type}`, fn);
    } else {
      //其他
      el[type] = fn;
    }
  }
  ```

### **观察者模式**

- 设计意图：它定义了一种一对 N 的关系，让 N 个观察者对象同时观察某一个被观察者对象，这个被观察者对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。
- 具体划分：观察者模式，发布订阅(基于观察者模式的一种范式,只是多了一个中心去处理观察者和被观察者)

#### 观察者模式

- 设计：
  - 由被观察者和观察者组成，被观察者发生改变，观察者会收到通知
- 场景：
  - 一个对象(观察者)的行为依赖于另一个对象(被观察者)的状态，这个被观察者才是重点
- 总结：
  - 观察者和被观察者它们之间是抽象耦合的，并且建立了异步触发机制；
  - 当订阅者比较多的时候，同时通知所有的订阅者可能会造成性能问题；无用的观察者需清除逻辑。
- 例如：
  - 发布订阅范式就是观察者模式，只是有一些不同于观察者模式的规范，所以它是一种范式
  - 例如警察在追击嫌犯，此时警察就是观察者，嫌犯就是被观察者；如果嫌犯只是拒捕，但并未做出其他动作，警察也只会口头警告 ‘put your hands up’；如果此时嫌犯拿起武器并向警察做出射击动作，警察会立马清空弹夹维护自身安全。

#### 发布订阅范式

- 设计：
  - 由发布者、订阅者和发布订阅中心组成，发布者和订阅者并不直接交互，发布者向中心发布内容，订阅者从中心订阅了某个 topic，某个 topic 变化后，中心去通知订阅者
- 场景：
  - 一个对象的行为依赖于另一个对象的状态，但是它们是相互独立的，由发布订阅中心来派发，这个中心才是重点
- 总结：
  - 观察者和被观察者它们之间是松耦合的，也具有高伸缩性，高灵活性，并且建立了异步触发机制；
- 例如：
  - js 中的事件流(dom.onclick 和 dom.click(),这个是一对一的)(多个 dom.addEventListener('click')和 dom.click(),这个是一对多)；
  - nodejs 的 events 的 EventEmitter(只是 eventEmitter 又是观察者(on)又是被观察者(emit))；
  - websocket,服务端的 websocket 可以既是观察者又是被观察者,客户端的- websocket 也是如此,可以相互 send 或者 onMessage；
  - 海量数据实时处理中心 kafka；
  - 异步事件流处理工具 RXJs；
  - 代码中发现有 watch、watcher、observe、observer、listen、listener、dispatch、trigger、emit、on、event、eventbus、EventEmitter 这类单词出现的地方
